<-- TorchScript + PyTroch JIT
	* IMOW
		- Convert pytorch model/code to more efficient representation Torchscript 
			to achieve faster inference and python independence
			by using either pytorch JIT function/decorator trace and script.

		- Benefits of Torchscript
			* faster inference time
			* Gets rid of Python GIL, a detriment to multithreading
			* Optimizs for common pattern
			* Export to a wide environment, ie java, to C++ servers or mobile.

		- Alternative to TouchSCript

	* Pytorch simultaniously aims for 
		- high developer speed/efficiency --> eager execution, non-graph allows dynamic speificatoin of train models. This may not be 			Onnx, but it requires model to be a DAG, ie no if else flow.
optmial for production, where a static graph is more robust and easier to optimize.

		- production at scale

	* TorchScript is a way to create serializable and optimizable models from PyTorch code”. Pytorch’s two modules JIT and TRACE allow the developer to export their model to be re-used in other programs

	* 2 Modes of Pytroch
		(1) Eager: for prototyping, and training, and expermientation


		(2) Script mode = { Pytorch JIT, Torchscript}

			(A) Pytorch JIT creates an OPTMIZED intermediate representation of the model, decoupling it from python (ie python GIL)

			(B) TorchScript is a static high-performance subset of Python language supporting 
				(i) complex control flows
				(ii) common data structures
				(iii) user defnied classes


	* Pytorch JIT
		- JIT Tracer
			 Tracer runs the supplied module and records the [tensor operations performed]. This recording is turned into a TorchScript module.

			 However, tracer omits the control flow, ds, and python constructs


			 Decorate your model/function: torch.jit.trace


		- JIT Script
			JIT script preserves control flows and other python constructs and looks more like Python. It has first-class support for lists/dictionaries.

			Decorate your model/function: torch.jit.script

			Unlike tracer, you do not need to pass in a data instance

	* Flow: 
		- Sample code: https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html#mixing-scripting-and-tracing


		- Use JIT (trace or script) on function/model to Touchscript model
			class MyDecisionGate(torch.nn.Module):
			    def forward(self, x):
			        if x.sum() > 0:
			            return x
			        else:
			            return -x

			class MyCell(torch.nn.Module):
			    def __init__(self, dg):
			        super(MyCell, self).__init__()
			        self.dg = dg
			        self.linear = torch.nn.Linear(4, 4)

			    def forward(self, x, h):
			        new_h = torch.tanh(self.dg(self.linear(x)) + h)
			        return new_h, new_h

			my_cell = MyCell(MyDecisionGate())
			traced_cell = torch.jit.trace(my_cell, (x, h))

			scripted_gate = torch.jit.script(MyDecisionGate())
			scripted_cell = torch.jit.script(my_cell)

			#test
			x, h = torch.rand(3, 4), torch.rand(3, 4)
			traced_cell(x, h)

		- Save 
			traced_cell.save('myModel.py')

		- Load Touchscript binary
			loaded = torch.jit.load('myModel.py')
			print(loaded.code)

		- infer
			loaded(inputTensors)
